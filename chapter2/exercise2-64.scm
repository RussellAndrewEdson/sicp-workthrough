;;; SICP Exercise 2.64
;;; (The online text can be found at 
;;;     http://mitpress.mit.edu/sicp/full-text/book/book.html)
;;;
;;; In this exercise, we examined a procedure for converting an ordered
;;; list into a binary tree, and determined the order of growth in the
;;; number of steps needed to convert a list of n elements.


; We have the procedure for converting an ordered list into a binary
; tree as follows (including the constructors and selectors for the
; binary tree data abstraction):

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))

(define (entry tree) (car tree))

(define (left-branch tree) (cadr tree))

(define (right-branch tree) (caddr tree))

(define (make-tree entry left right)
  (list entry left right))


; a)
; Now there's a lot of let expressions in that partial-tree definition,
; so it appears intimidating. However if we were to rewrite it into
; pseudocode with state variables (ie. in the procedural programming
; paradigm), the nature of the algorithm becomes a little easier to see.

; For starters, the return value for partial-tree consists of a cons
; cell with the portion of the tree contributed by -that- call in the
; left-hand slot, and the "remaining elements" that weren't used to
; construct that portion of the tree in the right-hand slot.

; So, when we call partial-tree with elts and n:
;   1. We check if n=0. If so, we simply return the empty list as the tree
;      contribution, and all of the elements in elts as the "remaining"
;      elements (since we used none.)
;
;   2. Otherwise, we calculate the left-hand side of the tree first.
;      This is done by dividing elts into two halves, and recursively 
;      operating on the first half.
;
;      Assuming the recursion works, after we're done here we should have 
;      the complete left-branch of the tree, and the elements that weren't
;      used to create the left branch will be in the "remaining elements" slot.
;
;   3. We take the first element of the remaining elements to be the "middle" 
;      value -- ie. that value that links the left and right branches.
;
;      In our top case, this should roughly correspond to the middle value of
;      the elts list.
;
;   4. Then we construct the entire right-hand side of the tree by
;      recursing through this algorithm with those elements left in the 
;      "remaining elements" list.
;
;      Assuming the recursion is sound, we'll have the complete right-branch
;      of the tree now, and a list of elements that weren't used in the 
;      construction of the tree.
;
;   5. Then we simply make the tree-portion by calling the constructor with
;      the "middle" entry and the left and right branches.


; So in a paragraph, the partial-tree procedure works by taking the given 
; portion of the list (delimited by the value of n) and dividing that portion
; into two halves, out of which the left-branch and right-branch for the tree
; are constructed. These branches are then linked by the middle value (the car
; of whatever elements weren't in the left-branch.) And those left and right
; branches are themselves constructed by recursively calling the procedure 
; until we reach a base case (where we create the leaves of the tree by 
; setting the left/right branches to be empty lists.)

; Check out exercise2-64_diagram.png for the tree generated by the list 
; (1 3 5 7 9 11), as well as a helpful diagram of the process that works to
; generate that tree.


; b)       
; Now let's check out the order of growth in the number of steps required
; by list->tree to convert a list of n elements.

; Notice that the main point of our algorithm is that we divide the list
; into halves each time. So you could think of this as us dividing n in
; half each time until we reach the base case where n=0. As we've seen 
; before, there are log_2(n) divisions required.

; However, we do this for both the left and right branches of the tree,
; for all levels of the tree. So we have about 2^log_2(n) divisions all up,
; which evens out to about n divisions. 

; Since dividing the list is all our algorithm is really doing at any point
; (there's nothing too special about our make-tree procedure, so the only
; thing that affects the number of steps we do is the number of divisions
; we need to make), then we can say that we have approximately n steps.

; That gives us an order of growth of Theta(n).